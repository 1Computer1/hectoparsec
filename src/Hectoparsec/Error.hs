{-# LANGUAGE StandaloneDeriving   #-}
{-# LANGUAGE UndecidableInstances #-}

{-|
Module      : Hectoparsec.Error
Copyright   : (c) comp 2020
License     : MIT
Maintainer  : onecomputer00@gmail.com
Stability   : stable
Portability : portable

Data types for errors reported during parsing.

Hectoparsec itself does not come with error pretty printing, instead, it is recommended that you use it with the
Errata (<https://hackage.haskell.org/package/errata>) library.
-}
module Hectoparsec.Error
    ( -- * Parse error data
      Unexpected(..)
    , ErrorItem(..)
    , ParseError(..)
    ) where

import Hectoparsec.Pos
import Hectoparsec.Stream

-- | An unexpected item from the input stream.
data Unexpected s
    = UnexpectedToken (Token s) -- ^ An unexpected token.
    | UnexpectedChunk (Chunk s) -- ^ An unexpected chunk.
    | UnexpectedEnd             -- ^ An unexpected end of input.
    | UnexpectedEmpty           -- ^ An unexpected empty parser.

-- | Chooses between two unexpected items. 'UnexpectedEmpty' items are discarded in favor of more descriptive items.
instance Semigroup (Unexpected s) where
    UnexpectedEmpty <> a = a
    a <> UnexpectedEmpty = a
    _ <> a = a

instance Monoid (Unexpected s) where
    mempty = UnexpectedEmpty

deriving instance (Show (Token s), Show (Chunk s)) => Show (Unexpected s)
deriving instance (Eq (Token s), Eq (Chunk s)) => Eq (Unexpected s)

-- | A possible error during parsing for a stream @s@, with error type @e@ and label type @l@.
data ErrorItem s e l
      {-|
      An error generated through matching tokens. There is an unexpected item and a list of labels from parsers that
      make up the expected items. There may be duplicates in the list of expected labels, so it is up to you to
      deduplicate it if needed.

      These errors are discared in favor of custom ones.
      -}
    = ErrorItemLabels (Unexpected s) [l]
      {-|
      An error generated by 'fail' and by parsers with broken invariants. You should not use these for your own errors
      as it lacks source position information. Instead, use 'ErrorItemCustom'.

      These errors are the least preferred.
      -}
    | ErrorItemFail String
      {-|
      A custom parse error.

      These errors are the most preferred.
      -}
    | ErrorItemCustom !e

deriving instance (Show (Token s), Show (Chunk s), Show e, Show l) => Show (ErrorItem s e l)
deriving instance (Eq (Token s), Eq (Chunk s), Eq e, Eq l) => Eq (ErrorItem s e l)

-- | A container for an error during parsing for a stream @s@, with error type @e@ and label type @l@.
data ParseError s e l = ParseError
    { parseErrorPos    :: !Pos                -- ^ The position of the error in the source.
    , parseErrorOffset :: {-# UNPACK #-} !Int -- ^ The offset of the error in the stream.
    , parseErrorItem   :: ErrorItem s e l     -- ^ The error item.
    }

deriving instance (Show (Token s), Show (Chunk s), Show e, Show l) => Show (ParseError s e l)
deriving instance (Eq (Token s), Eq (Chunk s), Eq e, Eq l) => Eq (ParseError s e l)

{-|
Merges two errors together. Errors that occur later in the stream are preferrred.

When errors occur at the same place, we prefer custom errors, unexpected items, then failures.
-}
instance Semigroup (ParseError s e l) where
    x <> y = case compare (parseErrorOffset x) (parseErrorOffset y) of
        LT -> y
        GT -> x
        -- We prefer the second state when they are equal in offset.
        EQ -> ParseError (parseErrorPos y) (parseErrorOffset y) $
            case (parseErrorItem x, parseErrorItem y) of
                (_, e@(ErrorItemCustom _)) -> e
                (e@(ErrorItemCustom _), _) -> e
                (ErrorItemLabels xunex xls, ErrorItemLabels yunex yls) -> ErrorItemLabels (xunex <> yunex) (xls <> yls)
                (_, e@(ErrorItemLabels _ _)) -> e
                (e@(ErrorItemLabels _ _), _) -> e
                (_, e) -> e
    {-# INLINE (<>) #-}
